# codebase-packager-archiver
A set of Python utilities for packaging a project's source code into a single RTF file, extracting files from the packaged format, and undoing the extraction. Respects .gitignore rules when packaging. Useful for creating project snapshots, backups, or documentation."

Functionality

pack.py

Functionality: This script scans the current working directory and its subdirectories, reads the contents of each file (respecting .gitignore rules and some additional exclusions), and writes them into a single .rtf (Rich Text Format) file.
Key Features:
.gitignore parsing: read_gitignore() handles reading and interpreting patterns from a .gitignore file.
Exclusion handling: should_exclude() checks for both directory and file exclusions.
Unique output file: get_unique_output_filename() ensures that the output file doesn't overwrite existing files by appending a numerical suffix if needed.
RTF output: scan_and_write_to_rtf() walks the directory structure, reads file contents, and formats them into an RTF file.
Purpose: This script is useful for creating a single document containing all the source code in a project, excluding specified files and directories. This could be helpful for generating documentation or for creating a snapshot of the codebase.
pack-all.py

Functionality: This script is very similar to pack.py, but with a crucial difference: it only excludes .py files and does not respect .gitignore rules. It essentially packages all non-Python files into a single .rtf file.
Key Features:
Simplified Exclusion: should_exclude() only checks for .py file extensions.
No .gitignore handling: It does not process .gitignore.
Rest is the same as pack.py
Purpose: A more specialized version of pack.py that focuses on packaging all non-Python files. This could be helpful for generating documentation or backups for specific parts of a project.
unpack.py

Functionality: This script takes an input file (presumably generated by pack.py or pack-all.py) that contains file paths and content in a specific format and recreates the original file structure based on this input.
Key Features:
File path parsing: It reads lines starting with // to identify file paths.
Content extraction: It collects the lines following the file path declaration as the file content.
Directory creation: save_file() ensures that the directory structure for each file exists before writing the file.
Purpose: This script is the counterpart to the pack scripts. It reverses the process, allowing you to reconstruct a project's file structure from the packaged RTF output.
unpack-undo.py

Functionality: This script takes an input file similar to unpack.py but instead of creating the files, it deletes them. It also cleans up any empty directories that result from the file deletions.
Key Features:
File path parsing: Similar to unpack.py, it reads file paths from lines starting with //.
File deletion: delete_file() deletes the file if it exists.
Empty directory cleanup: remove_empty_directories() recursively removes empty directories.
Purpose: This script is designed to undo the actions of unpack.py. It provides a way to clean up files that were extracted from the packaged format.
